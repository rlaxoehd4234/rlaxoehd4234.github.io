---
title: "운영체제와 DB 세션의 진짜 비용: 커넥션 풀 심화 탐구"
date: "2025-09-03"
author: "남성"
image: "https://tse2.mm.bing.net/th/id/OIP.WjDVH8u5aCImfOq39oMMHwHaF7?pid=Api"
description: "요청 스레드부터 DB 세션까지, 운영체제와 데이터베이스 레벨에서 발생하는 커넥션 관리 비용을 심층 분석"
---

# 운영체제와 DB 세션의 진짜 비용: 커넥션 풀 심화 탐구

![DB Connection Pool 구조](https://tse2.mm.bing.net/th/id/OIP.WjDVH8u5aCImfOq39oMMHwHaF7?pid=Api)

---

## 0. 요청 처리 흐름: 스레드에서 세션까지 한 사이클

애플리케이션 서버(Spring, Django, Delphi 등)가 DB와 대화하는 과정은 단순히 `쿼리 실행`이 아닙니다.  
운영체제와 DBMS 양쪽에서 스레드, 소켓, 세션, 락 관리가 연쇄적으로 발생합니다.  
흐름을 단계별로 살펴보겠습니다.

1. **HTTP 요청 수신**
   - 톰캣(Tomcat) 같은 서블릿 컨테이너가 요청을 받습니다.
   - `maxThreads`만큼 준비된 워커 스레드 중 하나가 해당 요청을 담당합니다.
   - → OS 레벨에서는 **실제 스레드**가 깨어나서 동작.

2. **커넥션 풀 접근**
   - 애플리케이션 스레드는 DB 작업이 필요할 때 HikariCP 같은 **커넥션 풀**에 커넥션을 요청합니다.
   - 풀에 여유 커넥션이 있다면 즉시 획득, 없다면 대기열(queue)에서 기다립니다.

3. **DB 세션 매핑**
   - 풀에서 반환된 커넥션은 실제로 DB 서버에 열린 **세션(Session)**과 연결됩니다.
   - 세션 내부에는 인증 정보, 트랜잭션 상태, 커서(cursor), 캐시 포인터 등이 준비되어 있음.

4. **쿼리 실행 (DB 작업)**
   - 세션과 연결된 DB 서버의 스레드/프로세스가 쿼리를 수행합니다.
   - → OS 레벨에서는 DBMS 프로세스 안에서 **별도의 스레드/프로세스 컨텍스트**가 동작.

5. **커넥션 반납**
   - 결과가 반환되면 커넥션은 닫지 않고 풀에 다시 반납됩니다.
   - 이때 트랜잭션 종료(커밋/롤백), 세션 상태 초기화가 발생.

6. **요청 스레드 종료**
   - 애플리케이션 워커 스레드는 HTTP 응답을 클라이언트로 반환한 뒤 풀에 대기 상태로 돌아갑니다.

---

## 1. 운영체제 레벨 리소스 소모

### 1.1. 워커 스레드
- 톰캣 워커 스레드는 **운영체제 스레드**와 1:1 매핑.
- 스레드 수가 늘어날수록 CPU 스케줄링, 문맥 전환 비용이 증가.
- `maxThreads`를 200 이상 크게 잡는 것은 가능하지만, DB 풀 크기보다 지나치게 많으면 **대기 스레드 폭증**.

### 1.2. 네트워크 소켓
- 각 DB 커넥션은 TCP 소켓을 통해 통신.
- OS 커널에서 송수신 버퍼(수 KB~수십 KB)와 FD(File Descriptor)를 유지.
- 수백~수천 개 연결이 쌓이면 **커널 메모리 + FD 고갈 위험**.

---

## 2. DBMS 레벨 리소스 소모

### 2.1. 세션(Session) 구조체
- 클라이언트마다 세션 객체를 유지.
- 트랜잭션 상태, 사용자 인증, 임시 테이블, 커서, 락 관리 정보 포함.
- 수십 KB ~ 수백 KB 메모리를 세션당 점유.

### 2.2. 스레드/프로세스
- MySQL: Thread per connection  
- PostgreSQL: Process per connection  
- 연결이 1000개라면 OS 레벨 스레드/프로세스도 1000개 생성 → **문맥 전환 폭증**.

### 2.3. 락/트랜잭션 매니저
- 세션마다 락, 트랜잭션 상태를 추적.
- 세션 수가 많아질수록 락 매니저의 동기화 비용이 기하급수적으로 증가.

### 2.4. 보안 및 감사 로그
- 세션마다 권한 검사, 감사 로깅이 별도로 수행됨.
- 많은 세션은 **로그 기록량 증가**로 이어짐.

---

## 3. 커넥션 풀의 필요성과 역할

### 3.1. 커넥션 생성 비용
- 매 요청마다 DB 연결을 열면:
  - TCP 핸드셰이크 + 인증 → 10~100ms 이상의 지연.
  - DB 세션 객체 생성 → CPU/메모리 오버헤드.
- 반복 루프에서 `open/close`를 하면 **폭발적 비용** 발생.

### 3.2. 풀 재사용 효과
- 미리 만들어 둔 커넥션을 재활용 → 생성 비용 회피.
- 애플리케이션은 빠르게 DB 세션을 빌려쓰고, 작업 끝나면 반납.

### 3.3. 스로틀링(Throttling) 역할
- 커넥션 풀 크기를 제한함으로써 DB가 감당할 수 있는 수준 이상으로 부하가 몰리지 않도록 보호.
- 톰캣 200 스레드가 동시에 DB를 때리더라도, 풀 크기가 30이라면 **30개 세션만 동시 처리, 나머지는 대기**.

---

## 4. 운영 전략: 톰캣 스레드 vs DB 커넥션 풀

- **톰캣 스레드 수 (`maxThreads`)**  
  - CPU 코어 수 × 10~20 정도까지 가능.  
  - 너무 크면 스레드 대기/문맥 전환 비용 ↑.

- **DB 커넥션 풀 크기 (`maximumPoolSize`)**  
  - CPU 코어 수 × 2~4 수준 권장.  
  - 일반적으로 20~50 수준에서 안정적 운영.  
  - DB 서버 메모리/스레드 한계 고려 필수.

---

## 5. 종합 테이블

| 범주            | 리소스 사용                         | 병목 지점                  |
|-----------------|----------------------------------|--------------------------|
| 톰캣 워커 스레드 | OS 스레드, CPU 문맥 전환 비용        | 스레드 수 과다 시 CPU 오버헤드 |
| 커넥션 풀        | TCP 소켓, DB 세션 매핑              | 풀 크기 이상 대기 발생       |
| DB 세션         | 메모리, 트랜잭션, 커서, 락 관리       | 세션 수 과다 시 락/캐시 부하   |
| DB 스레드/프로세스 | OS 스레드/프로세스 자원, 스케줄링 비용 | 1000개 이상 시 급격한 성능 저하 |

---

## 결론

**DB 커넥션은 단순한 소켓이 아니다.**  
그 안에는 운영체제 자원(스레드, 소켓, 버퍼)과 DBMS 내부 리소스(세션, 락, 트랜잭션, 프로세스)가 복합적으로 얽혀 있습니다.  

따라서 커넥션 풀은 **재사용(성능 최적화)**과 **제한(부하 제어)**라는 두 가지 측면에서 필수적인 인프라입니다.  
안정적 시스템을 운영하려면 톰캣 스레드와 DB 풀 크기의 균형을 잡아, CPU/메모리/DBMS 리소스를 초과하지 않도록 관리해야 합니다.
